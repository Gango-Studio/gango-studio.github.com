<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>圆形节拍器</title>
    <style>
        /* 保持原有样式不变 */
    </style>
</head>
<body>
    <!-- 保持原有HTML结构不变 -->
    <div class="wheel-container">
        <div class="control-wheel"></div>
        <div class="center-display">
            <span id="bpm">120</span>
            <span>BPM</span>
        </div>
    </div>
    <button id="toggle">Start</button>

    <script>
        // 使用更精确的定时器
        let isPlaying = false;
        let intervalId = null;
        let rotation = 0;
        let currentBpm = 120;
        let lastPlayTime = 0;

        // 音频对象
        const audio = new Audio('metronome.wav');
        audio.preload = 'auto';

        // 元素引用
        const wheel = document.querySelector('.control-wheel');
        const bpmDisplay = document.getElementById('bpm');
        const toggleBtn = document.getElementById('toggle');

        // 事件监听
        let isDragging = false;
        let lastAngle = 0;

        wheel.addEventListener('mousedown', startDrag);
        wheel.addEventListener('touchstart', startDrag);
        document.addEventListener('mousemove', handleDrag);
        document.addEventListener('touchmove', handleDrag);
        document.addEventListener('mouseup', stopDrag);
        document.addEventListener('touchend', stopDrag);

        function startDrag(e) {
            e.preventDefault();
            isDragging = true;
            const rect = wheel.getBoundingClientRect();
            const centerX = rect.left + rect.width/2;
            const centerY = rect.top + rect.height/2;
            const pos = getClientPos(e);
            lastAngle = Math.atan2(pos.y - centerY, pos.x - centerX);
        }

        function handleDrag(e) {
            if (!isDragging) return;
            e.preventDefault();

            const rect = wheel.getBoundingClientRect();
            const centerX = rect.left + rect.width/2;
            const centerY = rect.top + rect.height/2;
            const pos = getClientPos(e);
            const currentAngle = Math.atan2(pos.y - centerY, pos.x - centerX);
            
            const angleDiff = currentAngle - lastAngle;
            rotation += angleDiff * (180 / Math.PI);
            rotation = rotation % 360;
            
            currentBpm = Math.round(120 + rotation * 0.8);
            currentBpm = Math.max(30, Math.min(240, currentBpm));
            
            bpmDisplay.textContent = currentBpm;
            wheel.style.transform = `rotate(${rotation}deg)`;
            
            lastAngle = currentAngle;
        }

        function stopDrag() {
            isDragging = false;
        }

        // 改进的节拍器核心
        function playTick() {
            const now = performance.now();
            const interval = 60000 / currentBpm;

            if (now - lastPlayTime >= interval) {
                audio.currentTime = 0;
                audio.play().catch(() => {});
                lastPlayTime = now;
            }

            if (isPlaying) {
                requestAnimationFrame(playTick);
            }
        }

        // 节拍器控制
        toggleBtn.addEventListener('click', () => {
            isPlaying = !isPlaying;
            toggleBtn.textContent = isPlaying ? 'Stop' : 'Start';
            
            if (isPlaying) {
                lastPlayTime = performance.now();
                playTick();
            }
        });

        // 通用坐标获取函数
        function getClientPos(e) {
            if (e.touches) {
                return {
                    x: e.touches[0].clientX,
                    y: e.touches[0].clientY
                };
            }
            return {
                x: e.clientX,
                y: e.clientY
            };
        }

        // 防止页面滚动
        document.body.addEventListener('touchmove', (e) => {
            if(isDragging) e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
