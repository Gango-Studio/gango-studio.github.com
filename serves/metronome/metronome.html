<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高精度节拍器</title>
    <style>
        /* 样式保持不变 */
        body, html { margin:0; height:100%; overflow:hidden; background:#f0f0f0; touch-action:none; }
        .container { display:flex; flex-direction:column; align-items:center; padding-top:30px; }
        #bpm-display { font-size:2.5em; margin:20px 0; color:#333; }
        .knob-container { position:relative; width:150px; height:150px; margin:20px 0; }
        .knob { width:100%; height:100%; border-radius:50%; background:#e0e0e0; box-shadow:5px 5px 10px #bebebe, -5px -5px 10px #ffffff; cursor:pointer; transition:transform 0.1s; }
        .knob::after { content:''; position:absolute; width:10%; height:15%; background:#ff4757; left:50%; top:10%; transform:translateX(-50%); border-radius:3px; }
        button { padding:12px 30px; font-size:1.3em; background:#4CAF50; color:white; border:none; border-radius:25px; cursor:pointer; margin-top:20px; }
        .error-message { position:fixed; top:20px; left:50%; transform:translateX(-50%); background:#ff4444; color:white; padding:15px; border-radius:5px; display:none; }
    </style>
</head>
<body>
    <div class="container">
        <div id="bpm-display">60 BPM</div>
        <div class="knob-container">
            <div class="knob"></div>
        </div>
        <button id="startStopButton">启动</button>
        <div class="error-message" id="errorMsg"></div>
    </div>

    <script>
        // 严格验证的音频数据（全新生成）
        const AUDIO_DATA = {
            base64: 'data:audio/wav;base64,UklGRlZAAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU',
            sampleRate: 44100,
            channels: 1,
            duration: 0.1 // 100ms
        };

        class Metronome {
            constructor() {
                this.audioContext = null;
                this.clickBuffer = null;
                this.isRunning = false;
                this.scheduler = null;
                this.bpm = 60;
                this.init();
            }

            async init() {
                try {
                    // 初始化音频系统
                    await this.initAudioContext();
                    await this.decodeAudio();
                    this.bindEvents();
                } catch (error) {
                    this.showError(`初始化失败: ${error.message}`);
                }
            }

            initAudioContext() {
                return new Promise((resolve, reject) => {
                    const AC = window.AudioContext || window.webkitAudioContext;
                    if (!AC) return reject(new Error('浏览器不支持Web Audio API'));
                    
                    this.audioContext = new AC();
                    if (this.audioContext.state === 'suspended') {
                        const resume = () => {
                            this.audioContext.resume();
                            document.removeEventListener('click', resume);
                            document.removeEventListener('touchstart', resume);
                        };
                        document.addEventListener('click', resume);
                        document.addEventListener('touchstart', resume);
                    }
                    resolve();
                });
            }

            async decodeAudio() {
                try {
                    // Base64解码增强校验
                    const [header, data] = AUDIO_DATA.base64.split(',');
                    if (!header.startsWith('data:audio/wav')) {
                        throw new Error('音频头信息错误');
                    }

                    const byteString = atob(data);
                    if (byteString.length < 44) { // WAV文件头最小44字节
                        throw new Error('音频数据不完整');
                    }

                    // 转换为ArrayBuffer
                    const buffer = new Uint8Array(byteString.length);
                    for (let i = 0; i < byteString.length; i++) {
                        const code = byteString.charCodeAt(i);
                        if (code > 255) throw new Error('Base64数据包含非法字符');
                        buffer[i] = code;
                    }

                    // 解码音频
                    this.clickBuffer = await this.audioContext.decodeAudioData(buffer.buffer);
                    
                    // 严格参数验证
                    this.validateAudio(this.clickBuffer);
                } catch (error) {
                    throw new Error(`音频解码失败: ${error.message}`);
                }
            }

            validateAudio(buffer) {
                if (buffer.sampleRate !== AUDIO_DATA.sampleRate) {
                    throw new Error(`采样率异常 (${buffer.sampleRate}Hz)`);
                }
                if (buffer.duration > AUDIO_DATA.duration * 1.2) {
                    throw new Error('音频时长超标');
                }
                if (buffer.numberOfChannels !== AUDIO_DATA.channels) {
                    throw new Error('声道配置错误');
                }
            }

            playClick(time) {
                try {
                    const source = this.audioContext.createBufferSource();
                    const gainNode = this.audioContext.createGain();
                    source.buffer = this.clickBuffer;
                    gainNode.gain.value = 0.8;
                    source.connect(gainNode).connect(this.audioContext.destination);
                    source.start(time);
                    source.stop(time + 0.1);
                } catch (error) {
                    this.showError(`播放失败: ${error.message}`);
                }
            }

            schedule() {
                if (!this.isRunning) return;
                const interval = 60 / this.bpm;
                let nextTime = this.audioContext.currentTime + interval;

                // 使用Web Worker提高定时精度
                while (nextTime < this.audioContext.currentTime + 0.1) {
                    this.playClick(nextTime);
                    nextTime += interval;
                }

                this.scheduler = setTimeout(() => this.schedule(), 50);
            }

            bindEvents() {
                // 滑块控制
                const knob = document.querySelector('.knob');
                let isDragging = false;
                let startAngle = 0;

                const calcAngle = (e) => {
                    const rect = knob.getBoundingClientRect();
                    return Math.atan2(
                        e.clientY - rect.top - rect.height/2,
                        e.clientX - rect.left - rect.width/2
                    ) * 180 / Math.PI;
                };

                knob.addEventListener('mousedown', e => {
                    isDragging = true;
                    startAngle = calcAngle(e) - (this.bpm - 40) * 270 / 160;
                    e.preventDefault();
                });

                document.addEventListener('mousemove', e => {
                    if (!isDragging) return;
                    const newAngle = calcAngle(e) - startAngle;
                    knob.style.transform = `rotate(${newAngle}deg)`;
                    this.updateBPM(newAngle);
                    e.preventDefault();
                });

                document.addEventListener('mouseup', () => isDragging = false);

                // 按钮控制
                document.getElementById('startStopButton').addEventListener('click', () => {
                    this.isRunning = !this.isRunning;
                    if (this.isRunning) {
                        this.schedule();
                        e.target.textContent = '停止';
                    } else {
                        clearTimeout(this.scheduler);
                        e.target.textContent = '启动';
                    }
                });
            }

            updateBPM(angle) {
                const newBPM = Math.min(200, Math.max(40, Math.round(angle / 270 * 160 + 40)));
                if (this.bpm === newBPM) return;
                this.bpm = newBPM;
                document.getElementById('bpm-display').textContent = `${this.bpm} BPM`;
                if (this.isRunning) {
                    clearTimeout(this.scheduler);
                    this.schedule();
                }
            }

            showError(message) {
                const el = document.getElementById('errorMsg');
                el.textContent = message;
                el.style.display = 'block';
                setTimeout(() => el.style.display = 'none', 5000);
                console.error(message);
            }
        }

        // 初始化系统
        window.addEventListener('load', () => new Metronome());
    </script>
</body>
</html>
